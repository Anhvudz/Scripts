
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local player = Players.LocalPlayer

local function loadMyHub()
    local success, result = pcall(function()
        return loadstring(game:HttpGet('https://raw.githubusercontent.com/Anhvudz/Scripts/main/My%20hub%20script'))()
    end)
    if not success or not result then
        warn("Failed to load MyHub library. Check URL or network.")
        warn("Error:", result)
        return nil
    end
    return result
end

spawn(function()
    wait(1)
    
    local MyHub = loadMyHub()
    if not MyHub then 
        warn("MyHub failed to load!")
        return 
    end
    
    print("‚úÖ MyHub loaded successfully!")
    
    local Window = MyHub:CreateWindow({
        Name = "FAKE EXPLOITE HUB 100%%%%%",
        LoadingTitle = "Loading HUB...",
        LoadingSubtitle = "With CARD Features!"
    })
    
    if not Window then
        warn("Window creation failed!")
        return
    end

-- ============ TOOL HITBOX EXPANDER ============
local HitboxTab = Window:NewTab({Name = "Hitbox"})
local HitboxSection = HitboxTab:NewSection({Name = "Tool Hitbox Expander"})

-- Store original sizes
_G.OriginalHitboxSizes = _G.OriginalHitboxSizes or {}

-- Size settings
local hitboxSizeX = 5
local hitboxSizeY = 5
local hitboxSizeZ = 5

-- Size inputs
HitboxSection:NewTextBoxButton({
    Name = "Size X",
    PlaceholderText = "5",
    ButtonText = "Set",
    CurrentValue = "5",
    Flag = "HitboxX",
    Callback = function(text)
        hitboxSizeX = tonumber(text) or 5
        MyHub:Notify("Hitbox X", "Set to: " .. hitboxSizeX, 2)
    end,
})

HitboxSection:NewTextBoxButton({
    Name = "Size Y",
    PlaceholderText = "5",
    ButtonText = "Set",
    CurrentValue = "5",
    Flag = "HitboxY",
    Callback = function(text)
        hitboxSizeY = tonumber(text) or 5
        MyHub:Notify("Hitbox Y", "Set to: " .. hitboxSizeY, 2)
    end,
})

HitboxSection:NewTextBoxButton({
    Name = "Size Z",
    PlaceholderText = "5",
    ButtonText = "Set",
    CurrentValue = "5",
    Flag = "HitboxZ",
    Callback = function(text)
        hitboxSizeZ = tonumber(text) or 5
        MyHub:Notify("Hitbox Z", "Set to: " .. hitboxSizeZ, 2)
    end,
})

-- Quick presets
local PresetSection = HitboxTab:NewSection({Name = "Quick Presets"})

PresetSection:NewButton({
    Name = "Small (5x5x5)",
    Callback = function()
        hitboxSizeX, hitboxSizeY, hitboxSizeZ = 5, 5, 5
        MyHub:Notify("Preset", "Small hitbox selected", 2)
    end,
})

PresetSection:NewButton({
    Name = "Medium (10x10x10)",
    Callback = function()
        hitboxSizeX, hitboxSizeY, hitboxSizeZ = 10, 10, 10
        MyHub:Notify("Preset", "Medium hitbox selected", 2)
    end,
})

PresetSection:NewButton({
    Name = "Large (20x20x20)",
    Callback = function()
        hitboxSizeX, hitboxSizeY, hitboxSizeZ = 20, 20, 20
        MyHub:Notify("Preset", "Large hitbox selected", 2)
    end,
})

PresetSection:NewButton({
    Name = "Massive (50x50x50)",
    Callback = function()
        hitboxSizeX, hitboxSizeY, hitboxSizeZ = 50, 50, 50
        MyHub:Notify("Preset", "Massive hitbox selected", 2)
    end,
})

-- Main functionality
local ControlSection = HitboxTab:NewSection({Name = "Controls"})

-- Function to expand hitbox
local function expandToolHitbox(tool)
    if not tool then return false end
    
    -- Find handle or hitbox part
    local hitboxPart = tool:FindFirstChild("Hitbox") or tool:FindFirstChild("Handle") or tool:FindFirstChild("HitPart")
    
    -- Try to find any BasePart
    if not hitboxPart then
        for _, child in ipairs(tool:GetDescendants()) do
            if child:IsA("BasePart") and child.Name:lower():find("hit") or child.Name:lower():find("handle") then
                hitboxPart = child
                break
            end
        end
    end
    
    -- If still not found, use first BasePart
    if not hitboxPart then
        hitboxPart = tool:FindFirstChildOfClass("BasePart")
    end
    
    if not hitboxPart then
        return false
    end
    
    -- Save original size
    if not _G.OriginalHitboxSizes[hitboxPart] then
        _G.OriginalHitboxSizes[hitboxPart] = {
            Size = hitboxPart.Size,
            CanCollide = hitboxPart.CanCollide,
            Massless = hitboxPart.Massless,
            Transparency = hitboxPart.Transparency
        }
    end
    
    -- Apply new size
    hitboxPart.Size = Vector3.new(hitboxSizeX, hitboxSizeY, hitboxSizeZ)
    hitboxPart.CanCollide = false
    hitboxPart.Massless = true
    hitboxPart.Transparency = 0.5  -- Semi-transparent so you can see it
    
    print("‚úÖ Expanded hitbox:", hitboxPart.Name, "to", hitboxPart.Size)
    return true
end

-- Function to restore hitbox
local function restoreToolHitbox(tool)
    if not tool then return false end
    
    local hitboxPart = tool:FindFirstChild("Hitbox") or tool:FindFirstChild("Handle") or tool:FindFirstChild("HitPart")
    
    if not hitboxPart then
        for _, child in ipairs(tool:GetDescendants()) do
            if child:IsA("BasePart") and _G.OriginalHitboxSizes[child] then
                hitboxPart = child
                break
            end
        end
    end
    
    if hitboxPart and _G.OriginalHitboxSizes[hitboxPart] then
        local original = _G.OriginalHitboxSizes[hitboxPart]
        hitboxPart.Size = original.Size
        hitboxPart.CanCollide = original.CanCollide
        hitboxPart.Massless = original.Massless
        hitboxPart.Transparency = original.Transparency
        
        _G.OriginalHitboxSizes[hitboxPart] = nil
        
        print("‚úÖ Restored hitbox:", hitboxPart.Name)
        return true
    end
    
    return false
end

-- Apply to current tool
ControlSection:NewButton({
    Name = "üî® Expand Current Tool",
    Callback = function()
        local tool = player.Character and player.Character:FindFirstChildOfClass("Tool")
        
        if tool then
            local success = expandToolHitbox(tool)
            if success then
                MyHub:Notify("Hitbox", "Expanded: " .. tool.Name, 2)
            else
                MyHub:Notify("Error", "No hitbox part found!", 3)
            end
        else
            MyHub:Notify("Error", "No tool equipped!", 2)
        end
    end,
})

ControlSection:NewButton({
    Name = "‚Ü©Ô∏è Restore Current Tool",
    Callback = function()
        local tool = player.Character and player.Character:FindFirstChildOfClass("Tool")
        
        if tool then
            local success = restoreToolHitbox(tool)
            if success then
                MyHub:Notify("Hitbox", "Restored: " .. tool.Name, 2)
            else
                MyHub:Notify("Error", "Nothing to restore!", 2)
            end
        else
            MyHub:Notify("Error", "No tool equipped!", 2)
        end
    end,
})

-- Auto-expand toggle
ControlSection:NewToggle({
    Name = "Auto-Expand Tools",
    CurrentValue = false,
    Flag = "AutoExpandTools",
    Callback = function(Value)
        _G.AutoExpandTools = Value
        
        if Value then
            -- Expand current tool
            local tool = player.Character and player.Character:FindFirstChildOfClass("Tool")
            if tool then
                expandToolHitbox(tool)
            end
            
            MyHub:Notify("Auto-Expand", "Enabled! Equip tools to expand", 3)
        else
            MyHub:Notify("Auto-Expand", "Disabled", 2)
        end
    end,
})

-- Monitor tool equips
player.Character.ChildAdded:Connect(function(child)
    if _G.AutoExpandTools and child:IsA("Tool") then
        wait(0.1)  -- Small delay to ensure tool is fully loaded
        expandToolHitbox(child)
        MyHub:Notify("Auto-Expand", "Expanded: " .. child.Name, 2)
    end
end)

-- Handle character respawns
player.CharacterAdded:Connect(function(character)
    character.ChildAdded:Connect(function(child)
        if _G.AutoExpandTools and child:IsA("Tool") then
            wait(0.1)
            expandToolHitbox(child)
            MyHub:Notify("Auto-Expand", "Expanded: " .. child.Name, 2)
        end
    end)
end)

-- Expand all tools in backpack
ControlSection:NewButton({
    Name = "üì¶ Expand All Backpack Tools",
    Callback = function()
        local count = 0
        
        for _, tool in ipairs(player.Backpack:GetChildren()) do
            if tool:IsA("Tool") then
                if expandToolHitbox(tool) then
                    count = count + 1
                end
            end
        end
        
        MyHub:Notify("Backpack", "Expanded " .. count .. " tools", 2)
    end,
})

ControlSection:NewButton({
    Name = "üîÑ Restore All Tools",
    Callback = function()
        local count = 0
        
        -- Restore equipped tool
        local equippedTool = player.Character and player.Character:FindFirstChildOfClass("Tool")
        if equippedTool and restoreToolHitbox(equippedTool) then
            count = count + 1
        end
        
        -- Restore backpack tools
        for _, tool in ipairs(player.Backpack:GetChildren()) do
            if tool:IsA("Tool") and restoreToolHitbox(tool) then
                count = count + 1
            end
        end
        
        MyHub:Notify("Restore", "Restored " .. count .. " tools", 2)
    end,
})

-- Visual options
local VisualSection = HitboxTab:NewSection({Name = "Visual Options"})

VisualSection:NewToggle({
    Name = "Show Hitbox (Transparent)",
    CurrentValue = true,
    Flag = "ShowHitbox",
    Callback = function(Value)
        _G.ShowHitbox = Value
        
        local tool = player.Character and player.Character:FindFirstChildOfClass("Tool")
        if tool then
            local hitboxPart = tool:FindFirstChild("Hitbox") or tool:FindFirstChild("Handle") or tool:FindFirstChildOfClass("BasePart")
            if hitboxPart then
                hitboxPart.Transparency = Value and 0.5 or 0
            end
        end
    end,
})

VisualSection:NewToggle({
    Name = "Highlight Hitbox",
    CurrentValue = false,
    Flag = "HighlightHitbox",
    Callback = function(Value)
        _G.HighlightHitbox = Value
        
        local tool = player.Character and player.Character:FindFirstChildOfClass("Tool")
        if tool then
            local hitboxPart = tool:FindFirstChild("Hitbox") or tool:FindFirstChild("Handle") or tool:FindFirstChildOfClass("BasePart")
            
            if hitboxPart then
                if Value then
                    local highlight = Instance.new("SelectionBox")
                    highlight.Name = "HitboxHighlight"
                    highlight.Adornee = hitboxPart
                    highlight.LineThickness = 0.1
                    highlight.Color3 = Color3.fromRGB(255, 0, 0)
                    highlight.Parent = hitboxPart
                else
                    local highlight = hitboxPart:FindFirstChild("HitboxHighlight")
                    if highlight then highlight:Destroy() end
                end
            end
        end
    end,
})

-- Info section
local InfoSection = HitboxTab:NewSection({Name = "Information"})

InfoSection:NewLabel({
    Name = "‚ÑπÔ∏è How to use:"
})

InfoSection:NewLabel({
    Name = "1. Set size (X, Y, Z) or use preset"
})

InfoSection:NewLabel({
    Name = "2. Equip tool"
})

InfoSection:NewLabel({
    Name = "3. Click 'Expand Current Tool'"
})

InfoSection:NewLabel({
    Name = "4. Or enable 'Auto-Expand' for automatic"
})

InfoSection:NewButton({
    Name = "üìä Show Current Tool Info",
    Callback = function()
        local tool = player.Character and player.Character:FindFirstChildOfClass("Tool")
        
        if tool then
            local hitboxPart = tool:FindFirstChild("Hitbox") or tool:FindFirstChild("Handle") or tool:FindFirstChildOfClass("BasePart")
            
            if hitboxPart then
                local size = hitboxPart.Size
                MyHub:Notify("Tool Info",
                    "Tool: " .. tool.Name .. "\n" ..
                    "Part: " .. hitboxPart.Name .. "\n" ..
                    "Size: " .. math.floor(size.X) .. "x" .. math.floor(size.Y) .. "x" .. math.floor(size.Z), 5)
            else
                MyHub:Notify("Info", "No hitbox part found!", 2)
            end
        else
            MyHub:Notify("Error", "No tool equipped!", 2)
        end
    end,
})


-- Alternative method - Hook at module level
InfoSection:NewToggle({
    Name = "test",
    CurrentValue = false,
    Flag = "give soul",
    Callback = function(Value)
_G.Give = Value
        if Value then
task.spawn(function()
while _G.Give do
task.wait(0.02)
local r = game:GetService("Players").LocalPlayer.PlayerGui.GlovesButton.KillstreakAwaButton.Gamepad

if r then
r:FireServer()
end
end
end)
end
end
})

-- Alternative method - Hook at module level
InfoSection:NewToggle({
    Name = "Kill Aura",
    CurrentValue = false,
    Flag = "killAura",
    Callback = function(Value)
_G.Killing = Value
        if Value then
task.spawn(function()

while _G.Killing do
wait(1)
sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 112412400000)
sethiddenproperty(game.Players.LocalPlayer, "MaxSimulationRadius", 112412400000)
for i,d in pairs(game:GetService("Workspace"):GetDescendants()) do
    if d.ClassName == 'Humanoid' and d.Parent.Name ~= game.Players.LocalPlayer.Name then
        d.Health = 0
    end
end
end
end)
end
end,
})


local Other = Window:NewTab({Name = "Other"})
local OtherSection = Other:NewSection({Name = "time stop button‚úì‚úì‚úì‚úì"})

OtherSection:NewButton({
    Name = "Get Time Stop Button",
    Callback = function()
        MyHub:Notify("Time Stop", "Setting up button...", 2)
        
        -- Check if already running
        if _G.TimeStopButtonActive then
            MyHub:Notify("Warning", "Already active! Disable first.", 2)
            return
        end
        
        _G.TimeStopButtonActive = true
        
        -- Function to setup the button for current character
        local function setupTimeStopButton()
            -- Wait for character to load
            local character = player.Character or player.CharacterAdded:Wait()
            wait(0.5)  -- Extra wait for everything to load
            
            -- Find tool
            local tool = character:FindFirstChildOfClass("Tool") or player.Backpack:FindFirstChildOfClass("Tool")
            
            if not tool then
                warn("[TimeStop] No tool found!")
                return false
            end
            
            local handle = tool:WaitForChild("Handle", 5)
            if not handle then
                warn("[TimeStop] No handle found!")
                return false
            end
            
            print("[TimeStop] Setting up for tool:", tool.Name)
            
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local TweenService = game:GetService("TweenService")
            local UserInputService = game:GetService("UserInputService")
            local mouse = player:GetMouse()
            local playerGui = player.PlayerGui
            
            local equipped = false
            local onCooldown = false
            
            -- Wait for button to exist
            local skillButtons = playerGui:WaitForChild("SkillButtons", 10)
            if not skillButtons then
                warn("[TimeStop] SkillButtons not found!")
                return false
            end
            
            local buttons = skillButtons:WaitForChild("Buttons", 5)
            if not buttons then
                warn("[TimeStop] Buttons not found!")
                return false
            end
            
            local cButton = buttons:WaitForChild("CButton", 5)
            if not cButton then
                warn("[TimeStop] CButton not found!")
                return false
            end
            
            local tweenInfoSlow = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0)
            local tweenInfoFast = TweenInfo.new(0.1, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false, 0)
            
            -- Function to activate time stop
            local function activateTimeStop()
                if equipped and not onCooldown then
                    onCooldown = true
                    
                    -- Fire remote
                    local remote = ReplicatedStorage:FindFirstChild("StopTimeSkillP1")
                    if remote then
                        remote:FireServer("PararOTempo")
                    end
                    
                    -- Animate cooldown
                    if cButton:FindFirstChild("CD") then
                        TweenService:Create(cButton.CD, tweenInfoFast, {
                            Size = UDim2.new(1, 0, 1, 0)
                        }):Play()
                        
                        wait(0.1)
                        
                        TweenService:Create(cButton.CD, tweenInfoSlow, {
                            Size = UDim2.new(0, 0, 1, 0)
                        }):Play()
                    end
                    
                    wait(1)
                    onCooldown = false
                    
                    print("[TimeStop] Activated!")
                end
            end
            
            -- Connect button click
            local buttonConnection = cButton.MouseButton1Down:Connect(activateTimeStop)
            
            -- Connect key press (Z)
            local keyConnection = mouse.KeyDown:Connect(function(key)
                if key:lower() == "z" then
                    activateTimeStop()
                end
            end)
            
            -- Connect gamepad (RT)
            local gamepadConnection = UserInputService.InputBegan:Connect(function(input)
                if input.KeyCode == Enum.KeyCode.ButtonR2 then
                    activateTimeStop()
                end
            end)
            
            -- Tool equipped
            local equippedConnection = tool.Equipped:Connect(function()
                equipped = true
                cButton.Visible = true
                
                if UserInputService.KeyboardEnabled then
                    cButton.Skill.Text = "Z"
                elseif UserInputService.GamepadEnabled then
                    cButton.Skill.Text = "RT"
                end
                
                print("[TimeStop] Tool equipped!")
            end)
            
            -- Tool unequipped
            local unequippedConnection = tool.Unequipped:Connect(function()
                equipped = false
                cButton.Visible = false
                print("[TimeStop] Tool unequipped!")
            end)
            
            -- Store connections for cleanup
            _G.TimeStopConnections = {
                buttonConnection,
                keyConnection,
                gamepadConnection,
                equippedConnection,
                unequippedConnection
            }
            
            print("[TimeStop] ‚úÖ Setup complete!")
            MyHub:Notify("Time Stop", "‚úÖ Button active! Press Z or click button", 3)
            return true
        end
        
        -- Setup for current character
        setupTimeStopButton()
        
        -- Reconnect on respawn
        local respawnConnection = player.CharacterAdded:Connect(function()
            if not _G.TimeStopButtonActive then return end
            
            print("[TimeStop] Respawned! Reconnecting...")
            
            -- Disconnect old connections
            if _G.TimeStopConnections then
                for _, conn in ipairs(_G.TimeStopConnections) do
                    pcall(function() conn:Disconnect() end)
                end
            end
            
            -- Wait a bit for character to fully load
            wait(2)
            
            -- Setup again
            local success = setupTimeStopButton()
            if success then
                MyHub:Notify("Time Stop", "‚úÖ Reconnected after respawn!", 2)
            else
                MyHub:Notify("Time Stop", "‚ùå Failed to reconnect!", 3)
            end
        end)
        
        _G.TimeStopRespawnConnection = respawnConnection
    end
})

-- Add a disable button
OtherSection:NewButton({
    Name = "üõë Disable Time Stop Button",
    Callback = function()
        if not _G.TimeStopButtonActive then
            MyHub:Notify("Info", "Time Stop not active", 2)
            return
        end
        
        _G.TimeStopButtonActive = false
        
        -- Disconnect all connections
        if _G.TimeStopConnections then
            for _, conn in ipairs(_G.TimeStopConnections) do
                pcall(function() conn:Disconnect() end)
            end
            _G.TimeStopConnections = nil
        end
        
        if _G.TimeStopRespawnConnection then
            _G.TimeStopRespawnConnection:Disconnect()
            _G.TimeStopRespawnConnection = nil
        end
        
        -- Hide button
        local playerGui = player.PlayerGui
        local cButton = playerGui:FindFirstChild("SkillButtons")
        if cButton then
            cButton = cButton:FindFirstChild("Buttons")
            if cButton then
                cButton = cButton:FindFirstChild("CButton")
                if cButton then
                    cButton.Visible = false
                end
            end
        end
        
        MyHub:Notify("Time Stop", "‚ùå Disabled!", 2)
    end
})

-- Toggle version
OtherSection:NewToggle({
    Name = "Auto-Reconnect Time Stop",
    CurrentValue = false,
    Flag = "AutoTimeStop",
    Callback = function(Value)
        if Value then
            -- Simulate clicking the enable button
            MyHub:Notify("Auto Time Stop", "Enabling...", 2)
            -- You'd need to refactor the code above into a function to call here
        else
            -- Disable
            _G.TimeStopButtonActive = false
            MyHub:Notify("Auto Time Stop", "Disabled", 2)
        end
    end
})


-- ============ OTHER TAB (DAMAGE SYSTEM + AUTO FARM) ============
local OtherTab = Window:NewTab({Name = "deadly-GameBreak-farm"})

-- ============ DAMAGE SYSTEM ============
local DamageSection = OtherTab:NewSection({Name = "üí• Damage System"})

-- Current target storage
_G.CurrentTarget = nil
_G.SelectedTargetName = ""

-- Target name input
DamageSection:NewTextBoxButton({
    Name = "Target Name",
    PlaceholderText = "Enter name or 'Player123'",
    ButtonText = "Set",
    Flag = "TargetName",
    Callback = function(text)
        _G.SelectedTargetName = text
        MyHub:Notify("Target", "Set to: " .. text, 2)
    end,
})

-- Damage amount slider
local damageAmount = 10

DamageSection:NewSlider({
    Name = "Damage Amount",
    Range = {1, 1000},
    Increment = 1,
    CurrentValue = 10,
    Flag = "DamageAmount",
    Callback = function(Value)
        damageAmount = Value
    end,
})

-- Quick damage presets
local PresetSection = OtherTab:NewSection({Name = "Quick Damage Presets"})

PresetSection:NewButton({
    Name = "Low (10)",
    Callback = function()
        damageAmount = 10
        MyHub:Notify("Damage", "Set to 10", 2)
    end,
})

PresetSection:NewButton({
    Name = "Medium (100)",
    Callback = function()
        damageAmount = 100
        MyHub:Notify("Damage", "Set to 100", 2)
    end,
})

PresetSection:NewButton({
    Name = "High (500)",
    Callback = function()
        damageAmount = 500
        MyHub:Notify("Damage", "Set to 500", 2)
    end,
})

PresetSection:NewButton({
    Name = "Max (1000)",
    Callback = function()
        damageAmount = 1000
        MyHub:Notify("Damage", "Set to 1000", 2)
    end,
})

-- Player/NPC List
local TargetSection = OtherTab:NewSection({Name = "üéØ Target Selection"})

-- Function to get all valid targets
local function getAllTargets()
    local targets = {}
    
    -- Get players
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= player and plr.Character and plr.Character:FindFirstChild("Humanoid") then
            table.insert(targets, {
                Name = plr.Name,
                Type = "Player",
                Model = plr.Character
            })
        end
    end
    
    -- Get NPCs from workspace
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and obj:FindFirstChild("Humanoid") and obj ~= player.Character then
            -- Check if it's in Map.Dummy or just a valid NPC
            if obj.Parent and (obj.Parent.Name == "Dummy" or obj.Parent.Name == "Map" or obj.Parent == workspace) then
                table.insert(targets, {
                    Name = obj.Name,
                    Type = "NPC",
                    Model = obj
                })
            end
        end
    end
    
    return targets
end

-- Create target dropdown
local targetOptions = {"None"}
local targetDropdown

local function updateTargetList()
    local targets = getAllTargets()
    targetOptions = {"None"}
    
    for _, target in ipairs(targets) do
        table.insert(targetOptions, target.Name .. " (" .. target.Type .. ")")
    end
    
    -- If dropdown exists, we'd need to recreate it
    -- For now, just notify
    MyHub:Notify("Targets", "Found " .. #targets .. " targets", 2)
end

TargetSection:NewButton({
    Name = "üîÑ Refresh Target List",
    Callback = function()
        updateTargetList()
    end,
})

-- Manual target selection dropdown
TargetSection:NewDropdown({
    Name = "Select Target",
    Options = {"None", "Nearest Player", "Nearest NPC"},
    CurrentOption = "None",
    Flag = "TargetSelect",
    Callback = function(Option)
        if Option == "Nearest Player" then
            local nearest = nil
            local nearestDist = math.huge
            
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local dist = (plr.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
                    if dist < nearestDist then
                        nearestDist = dist
                        nearest = plr.Character
                    end
                end
            end
            
            _G.CurrentTarget = nearest
            MyHub:Notify("Target", nearest and "Selected: " .. nearest.Name or "No players found", 2)
            
        elseif Option == "Nearest NPC" then
            local nearest = nil
            local nearestDist = math.huge
            
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj:IsA("Model") and obj:FindFirstChild("Humanoid") and obj:FindFirstChild("HumanoidRootPart") and obj ~= player.Character then
                    local dist = (obj.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
                    if dist < nearestDist then
                        nearestDist = dist
                        nearest = obj
                    end
                end
            end
            
            _G.CurrentTarget = nearest
            MyHub:Notify("Target", nearest and "Selected: " .. nearest.Name or "No NPCs found", 2)
        else
            _G.CurrentTarget = nil
            MyHub:Notify("Target", "Cleared", 2)
        end
    end,
})

-- Fire damage button
local AttackSection = OtherTab:NewSection({Name = "‚öîÔ∏è Attack Actions"})

AttackSection:NewButton({
    Name = "üî• Fire Damage",
    Callback = function()
        local target = _G.CurrentTarget
        
        if not target then
            MyHub:Notify("Error", "No target selected!", 2)
            return
        end
        
        local ch = player.Character
        if not ch then return end
        
        local effects = ch:FindFirstChild("Effects")
        if not effects then
            MyHub:Notify("Error", "Effects folder not found!", 2)
            return
        end
        
        local remote = effects:FindFirstChild("DMF")
        if not remote or not remote:IsA("RemoteEvent") then
            MyHub:Notify("Error", "DMF remote not found!", 2)
            return
        end
        
        local targetPart = target:FindFirstChild("HumanoidRootPart") or target:FindFirstChild("Humanoid")
        if targetPart then
            remote:FireServer(targetPart, damageAmount)
            MyHub:Notify("Damage", "Fired " .. damageAmount .. " damage!", 2)
        end
    end,
})

-- ============ KILL AURA ============
local KillAuraSection = OtherTab:NewSection({Name = "‚ö° Kill Aura"})

KillAuraSection:NewToggle({
    Name = "Kill Aura",
    CurrentValue = false,
    Flag = "KillAura",
    Callback = function(Value)
        _G.KillAura = Value
        
        if Value then
            spawn(function()
                while _G.KillAura do
                    local ch = player.Character
                    if ch and ch:FindFirstChild("HumanoidRootPart") then
                        local effects = ch:FindFirstChild("Effects")
                        local remote = effects and effects:FindFirstChild("DMF")
                        
                        if remote then
                            -- Find all nearby targets
                            for _, obj in ipairs(workspace:GetDescendants()) do
                                if obj:IsA("Model") and obj ~= ch and obj:FindFirstChild("Humanoid") then
                                    local hrp = obj:FindFirstChild("HumanoidRootPart")
                                    if hrp then
                                        local dist = (hrp.Position - ch.HumanoidRootPart.Position).Magnitude
                                        
                                        if dist <= (_G.KillAuraRange or 20) then
                                            local target = hrp or obj.Humanoid
                                            remote:FireServer(target, damageAmount)
                                        end
                                    end
                                end
                            end
                        end
                    end
                    
                    wait(_G.KillAuraDelay or 0.1)
                end
            end)
            
            MyHub:Notify("Kill Aura", "Enabled!", 2)
        else
            MyHub:Notify("Kill Aura", "Disabled!", 2)
        end
    end,
})

KillAuraSection:NewSlider({
    Name = "Kill Aura Range",
    Range = {5, 1500},
    Increment = 1,
    CurrentValue = 20,
    Flag = "KillAuraRange",
    Callback = function(Value)
        _G.KillAuraRange = Value
    end,
})

KillAuraSection:NewSlider({
    Name = "Attack Delay (seconds)",
    Range = {0.1, 5},
    Increment = 0.1,
    CurrentValue = 0.1,
    Flag = "KillAuraDelay",
    Callback = function(Value)
        _G.KillAuraDelay = Value
    end,
})

  -- ============ AUTO FARM ============
local AutoFarmSection = OtherTab:NewSection({Name = "ü§ñ Auto Farm"})

-- Services
local PathfindingService = game:GetService("PathfindingService")

-- Auto farm state
_G.AutoFarmRunning = false
_G.AutoFarmTarget = nil
_G.CurrentPath = nil

-- Safety configuration
local MIN_HEIGHT = -200 -- Minimum Y position before considering void (arena is at -164)
local MAX_CHASE_DISTANCE = 500 -- Stop chasing if target is too far
local ATTACK_RANGE = 10 -- Distance to attack from
local WAYPOINT_REACH_DISTANCE = 5 -- Distance to consider waypoint reached
local SAFE_ATTACK_HEIGHT_DIFF = 8 -- Max height difference to attack (prevents standing on head)
local TARGET_REVALIDATE_TIME = 0.3 -- How often to check if target is still valid

-- Function to check if position is safe (not in void)
local function isSafePosition(position)
    if not position then return false end
    return position.Y > MIN_HEIGHT
end

-- Function to check if target is valid and safe
local function isTargetValid(dummy)
    if not dummy or not dummy:FindFirstChild("Humanoid") or dummy.Humanoid.Health <= 0 then
        return false
    end
    
    local hrp = dummy:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    -- Check if target is in safe position
    if not isSafePosition(hrp.Position) then
        return false
    end
    
    -- Check if target is not falling too fast (knocked into void)
    if hrp.AssemblyLinearVelocity.Y < -50 then
        return false
    end
    
    return true
end

-- Function to check if can attack target safely
local function canAttackTarget(playerHRP, targetHRP)
    if not playerHRP or not targetHRP then return false end
    
    local heightDiff = math.abs(playerHRP.Position.Y - targetHRP.Position.Y)
    
    -- Don't attack if standing on target's head or target is way above/below
    if heightDiff > SAFE_ATTACK_HEIGHT_DIFF then
        return false
    end
    
    -- Check horizontal distance only
    local horizontalDist = Vector3.new(
        targetHRP.Position.X - playerHRP.Position.X,
        0,
        targetHRP.Position.Z - playerHRP.Position.Z
    ).Magnitude
    
    return horizontalDist < ATTACK_RANGE
end

-- Function to find nearest dummy
local function findNearestDummy()
    local nearest = nil
    local nearestDist = math.huge
    
    -- Check Map.Dummy folder
    local dummyFolder = workspace:FindFirstChild("Map")
    if dummyFolder then
        dummyFolder = dummyFolder:FindFirstChild("Dummy")
    end
    
    if dummyFolder then
        for _, dummy in ipairs(dummyFolder:GetChildren()) do
            if dummy:IsA("Model") and dummy:FindFirstChild("Humanoid") and dummy.Humanoid.Health > 0 then
                local hrp = dummy:FindFirstChild("HumanoidRootPart")
                if hrp and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    -- Check if dummy is in a safe position
                    if isSafePosition(hrp.Position) then
                        local dist = (hrp.Position - player.Character.HumanoidRootPart.Position).Magnitude
                        if dist < nearestDist and dist < MAX_CHASE_DISTANCE then
                            nearestDist = dist
                            nearest = dummy
                        end
                    end
                end
            end
        end
    end
    
    return nearest
end

-- Function to equip tool
local function equipTool()
    local tool = player.Character:FindFirstChildOfClass("Tool")
    if tool then return true end
    
    tool = player.Backpack:FindFirstChildOfClass("Tool")
    if tool then
        player.Character.Humanoid:EquipTool(tool)
        return true
    end
    
    return false
end

-- Function to create path to target
local function createPath(targetPosition)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return nil
    end
    
    local path = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true,
        AgentJumpHeight = 10,
        AgentMaxSlope = 45,
        Costs = {
            Water = 20
        }
    })
    
    local success, errorMsg = pcall(function()
        path:ComputeAsync(player.Character.HumanoidRootPart.Position, targetPosition)
    end)
    
    if success and path.Status == Enum.PathStatus.Success then
        return path
    end
    
    return nil
end

-- Function to follow path
local function followPath(path, targetPosition)
    if not path or not player.Character then return false end
    
    local humanoid = player.Character:FindFirstChild("Humanoid")
    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not hrp then return false end
    
    local waypoints = path:GetWaypoints()
    
    for i, waypoint in ipairs(waypoints) do
        if not _G.AutoFarmRunning then break end
        
        -- Skip waypoints that are behind the player
        local waypointDirection = (waypoint.Position - hrp.Position)
        local toTargetDirection = (targetPosition - hrp.Position)
        
        -- Check if waypoint is in the general direction of target
        if waypointDirection:Dot(toTargetDirection) < 0 and i > 1 then
            continue -- Skip waypoint behind us
        end
        
        -- Check distance to waypoint
        local distanceToWaypoint = (waypoint.Position - hrp.Position).Magnitude
        
        -- Skip if already close to waypoint
        if distanceToWaypoint < WAYPOINT_REACH_DISTANCE then
            continue
        end
        
        -- Check if current position is safe
        if not isSafePosition(hrp.Position) then
            return false
        end
        
        humanoid:MoveTo(waypoint.Position)
        
        if waypoint.Action == Enum.PathWaypointAction.Jump then
            humanoid.Jump = true
        end
        
        -- Wait until close to waypoint or timeout
        local timeout = 0
        local maxTimeout = 3 -- Reduced timeout
        
        repeat
            wait(0.05) -- Faster check
            timeout = timeout + 0.05
            
            if not hrp then break end
            local currentDist = (waypoint.Position - hrp.Position).Magnitude
            
            -- Break if close enough to waypoint
            if currentDist < WAYPOINT_REACH_DISTANCE then
                break
            end
            
        until timeout > maxTimeout or not _G.AutoFarmRunning
    end
    
    return true
end

-- Function to teleport to lobby portal
local function teleportToLobby()
    local portal = workspace:FindFirstChild("Lobby")
    if portal then
        portal = portal:FindFirstChild("Portal")
        if portal then
            portal = portal:FindFirstChild("Part")
            if portal and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                player.Character.HumanoidRootPart.CFrame = portal.CFrame
                return true
            end
        end
    end
    return false
end

-- Auto farm toggle
AutoFarmSection:NewToggle({
    Name = "Auto Farm Dummies",
    CurrentValue = false,
    Flag = "AutoFarm",
    Callback = function(Value)
        _G.AutoFarmRunning = Value
        
        if Value then
            spawn(function()
                MyHub:Notify("Auto Farm", "Starting...", 2)
                
                while _G.AutoFarmRunning do
                    local ch = player.Character
                    
                    -- Check if player is in void
                    if ch and ch:FindFirstChild("HumanoidRootPart") then
                        if not isSafePosition(ch.HumanoidRootPart.Position) then
                            -- Player is falling, stop and wait for respawn
                            MyHub:Notify("Auto Farm", "Detected void fall, waiting for respawn...", 2)
                            wait(5)
                            continue
                        end
                    end
                    
                    if not ch or not ch:FindFirstChild("Humanoid") or ch.Humanoid.Health <= 0 then
                        -- Dead or no character, wait for respawn
                        wait(3)
                        
                        -- Try to get tool
                        if not equipTool() then
                            -- No tool, go to portal
                            teleportToLobby()
                            wait(2)
                        end
                        
                        wait(1)
                    else
                        -- Equip tool if not equipped
                        if not equipTool() then
                            teleportToLobby()
                            wait(2)
                        else
                            -- Find nearest dummy
                            local dummy = findNearestDummy()
                            
                            if dummy and isTargetValid(dummy) then
                                _G.AutoFarmTarget = dummy
                                local hrp = dummy:FindFirstChild("HumanoidRootPart")
                                
                                if hrp and isSafePosition(hrp.Position) then
                                    -- Revalidate target continuously
                                    if not isTargetValid(dummy) then
                                        _G.AutoFarmTarget = nil
                                        wait(0.5)
                                        continue
                                    end
                                    
                                    local dist = (hrp.Position - ch.HumanoidRootPart.Position).Magnitude
                                    
                                    -- If target is too far or in void, find new target
                                    if dist > MAX_CHASE_DISTANCE then
                                        _G.AutoFarmTarget = nil
                                        wait(0.5)
                                        continue
                                    end
                                    
                                    -- Check if can safely attack
                                    if canAttackTarget(ch.HumanoidRootPart, hrp) then
                                        -- Stop moving to prevent climbing on head
                                        ch.Humanoid:MoveTo(ch.HumanoidRootPart.Position)
                                        wait(0.1)
                                        
                                        -- Double check target is still valid before attacking
                                        if not isTargetValid(dummy) then
                                            _G.AutoFarmTarget = nil
                                            continue
                                        end
                                        
                                        -- Activate tool
                                        local tool = ch:FindFirstChildOfClass("Tool")
                                        if tool then
                                            tool:Activate()
                                        end
                                        
                                        -- Fire damage
                                        local effects = ch:FindFirstChild("Effects")
                                        local remote = effects and effects:FindFirstChild("DMF")
                                        if remote then
                                            remote:FireServer(hrp, damageAmount)
                                        end
                                        
                                        wait(0.1)
                                    elseif dist < 30 then
                                        -- Close enough, check target before moving
                                        if isTargetValid(dummy) then
                                            -- Move slightly away if too close vertically
                                            local heightDiff = ch.HumanoidRootPart.Position.Y - hrp.Position.Y
                                            if heightDiff > 5 then
                                                -- We're above target, move back a bit
                                                local moveBack = ch.HumanoidRootPart.Position - (ch.HumanoidRootPart.CFrame.LookVector * 3)
                                                ch.Humanoid:MoveTo(moveBack)
                                                wait(0.3)
                                            else
                                                ch.Humanoid:MoveTo(hrp.Position)
                                            end
                                        else
                                            _G.AutoFarmTarget = nil
                                        end
                                    else
                                        -- Far away, validate before pathfinding
                                        if isTargetValid(dummy) then
                                            -- Use pathfinding
                                            local path = createPath(hrp.Position)
                                            if path then
                                                followPath(path, hrp.Position)
                                            else
                                                -- Pathfinding failed, use direct movement
                                                ch.Humanoid:MoveTo(hrp.Position)
                                            end
                                        else
                                            _G.AutoFarmTarget = nil
                                        end
                                    end
                                else
                                    -- Target is in void, abandon it
                                    _G.AutoFarmTarget = nil
                                end
                            else
                                -- No dummy found, wait
                                wait(1)
                            end
                        end
                    end
                    
                    wait(0.1)
                end
                
                MyHub:Notify("Auto Farm", "Stopped!", 2)
            end)
        end
    end,
})

AutoFarmSection:NewDropdown({
    Name = "Farm Target",
    Options = {"Nearest", "TestDummy1", "TestDummy2", "All Dummies"},
    CurrentOption = "Nearest",
    Flag = "FarmTarget",
    Callback = function(Option)
        _G.FarmTargetMode = Option
        MyHub:Notify("Farm Target", "Set to: " .. Option, 2)
    end,
})

AutoFarmSection:NewSlider({
    Name = "Max Chase Distance",
    Range = {50, 1000},
    Increment = 50,
    CurrentValue = 500,
    Flag = "MaxChaseDistance",
    Callback = function(Value)
        MAX_CHASE_DISTANCE = Value
        MyHub:Notify("Max Chase Distance", "Set to: " .. Value, 2)
    end,
})

AutoFarmSection:NewToggle({
    Name = "Auto Equip Tool",
    CurrentValue = true,
    Flag = "AutoEquipTool",
    Callback = function(Value)
        _G.AutoEquipTool = Value
    end,
})

AutoFarmSection:NewToggle({
    Name = "Auto Return to Lobby on Death",
    CurrentValue = true,
    Flag = "AutoReturnLobby",
    Callback = function(Value)
        _G.AutoReturnLobby = Value
    end,
})

AutoFarmSection:NewToggle({
    Name = "Void Protection",
    CurrentValue = true,
    Flag = "VoidProtection",
    Callback = function(Value)
        _G.VoidProtection = Value
        MyHub:Notify("Void Protection", Value and "Enabled" or "Disabled", 2)
    end,
})

-- Info section
local InfoSection = OtherTab:NewSection({Name = "‚ÑπÔ∏è Information"})

InfoSection:NewLabel({
    Name = "Damage System: Select target and fire damage"
})

InfoSection:NewLabel({
    Name = "Kill Aura: Attacks all nearby enemies"
})

InfoSection:NewLabel({
    Name = "Auto Farm: Farms dummies with pathfinding"
})

InfoSection:NewLabel({
    Name = "‚ö†Ô∏è Void Protection: Prevents falling deaths"
})

InfoSection:NewButton({
    Name = "üìä Show Current Status",
    Callback = function()
        local status = "Auto Farm: " .. (_G.AutoFarmRunning and "ON" or "OFF") .. "\n" ..
                      "Kill Aura: " .. (_G.KillAura and "ON" or "OFF") .. "\n" ..
                      "Target: " .. (_G.CurrentTarget and _G.CurrentTarget.Name or "None") .. "\n" ..
                      "Damage: " .. damageAmount .. "\n" ..
                      "Chase Distance: " .. MAX_CHASE_DISTANCE
        
        MyHub:Notify("Status", status, 5)
    end,
})

end)
